# This file was automatically generated by the backend
# Manual edits will not be persisted.

type AppConfig {
	name: String!
	apiUrl: String!
	frontendUrl: String!
}

type Artifact {
	name: String!
	url: String!
	signature: String
}

type Attachment {
	id: UUID!
	runId: UUID!
	name: String!
	mimeType: String!
	data: [Int!]!
	run: Run!
}

type Binary {
	id: UUID!
	projectId: UUID!
	versionMajor: Int!
	versionMinor: Int!
	versionPatch: Int!
	parts: [BinaryPart!]!
	project: Project!
	"""
	Get the size of the binary non-volatile memory in bytes.
	"""
	nvmSize: Int!
}

enum BinaryKind {
	ELF
	HEX
	BIN
}

type BinaryPart {
	id: UUID!
	name: String
	binaryId: UUID!
	kind: BinaryKind!
	memoryOffset: Int
	image: [Int!]!
	imageHash: [Int!]!
	sizeInMemory: Int!
	creationDate: NaiveDateTime!
	changeDate: NaiveDateTime!
}

type Block {
	"""
	The globally unique ID of this block.
	"""
	id: UUID!
	"""
	The device this block belongs to.
	"""
	run: Run!
	"""
	The schema of the block.
	
	The schema is a contract that has to be fulfilled for the block to be created.
	"""
	schema: BlockSchema!
	"""
	The data this block stores, in JSON format.
	"""
	dataDecoded: JSON!
	"""
	The data this block stores, in a continuous byte slice.
	
	This automatically transfers the stored data into a slice of bytes which can be written
	to device memory.
	
	Uses [`BlockSchema::to_bytes`] to transform the data.
	"""
	byteSlice: [Int!]!
}

type BlockSchema {
	id: UUID!
	isDeviceIdentifier: Boolean!
	projectId: UUID!
	name: String!
	schema: String!
	generator: String
	toBytes: String
	fromBytes: String
	memoryAddress: Int
	length: Int
	creationDate: NaiveDateTime!
	deactivationDate: NaiveDateTime
	source: BlockSource!
	active: Boolean!
	"""
	Determine if this schema can be used for requirements.
	"""
	supportsRequirements: Boolean!
}

"""
Indicates the source of data for a block.
"""
enum BlockSource {
	INPUT
	EXTERNAL
	DERIVED
}


type Chip {
	name: String!
	nvmSize: Int!
}

type Device {
	id: UUID!
	name: String
	projectId: UUID!
	creationDate: NaiveDateTime!
	changeDate: NaiveDateTime!
	project: Project!
	runs: [Run!]!
	"""
	The run with given UUID.
	
	If no UUID is given, the most recent run is returned.
	"""
	run(id: UUID): Run!
}

type DeviceConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [DeviceEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Device!]!
	numDevices: Int!
}

"""
An edge in a connection.
"""
type DeviceEdge {
	"""
	A cursor for use in pagination
	"""
	cursor: String!
	"""
	The item at the end of the edge
	"""
	node: Device!
}

type Family {
	id: UUID!
	definition: String!
	owner: Owner!
}


type Group {
	id: UUID!
}


input InsertBinaryPart {
	name: String
	kind: BinaryKind!
	memoryOffset: Int
	image: Upload!
}


"""
A scalar that can represent any JSON value.
"""
scalar JSON

type Log {
	id: UUID!
	runId: UUID!
	level: String!
	message: String!
	creationDate: NaiveDateTime!
	run: Run!
}

type MutationRoot {
	"""
	Creates a new device for given `project_id` and returns the device.
	"""
	deviceCreate: Device!
	signIn(username: String!, password: String!): String!
	"""
	Sign in with a given OAuth provider.
	
	# Arguments
	* `provider`: The provider to be used e.g. `google` or `github`.
	* `code`: The code that was returned from the request we sent to the provider.
	For more info see documentation on OAuth CSRF attack mitigation.
	* `nonce`: The nonce that was sent to the OIDC provider to mitigate replay attacks.
	This nonce is only required for real OIDC providers and not all OAuth providers.
	"""
	signInWithOauth(provider: String!, code: String!, csrfToken: String, nonce: String): String!
	refresh(token: String!): String!
	userCreate(username: String!, email: String!, password: String!): User!
	userConfirm(token: String!): Boolean!
	userApprove(id: UUID!): UUID!
	userResendConfirmCode(email: String!): Boolean!
	userRequestPasswordReset(email: String!): Boolean!
	userResetPassword(token: String!, newPassword: String!): Boolean!
	"""
	Change the current user's password.
	"""
	changePassword(currentPassword: String!, newPassword: String!): Boolean!
	"""
	Creates a new binary record and retursn the ID of the created record.
	"""
	binaryCreate(projectId: UUID!, version: String!, parts: [InsertBinaryPart!]!): Binary!
	"""
	Creates a new project for a user and returns the project upon successful creation.
	"""
	projectCreate(name: String!, chipName: String!): Project!
	provisionerCreate(name: String!, projectId: UUID!): Provisioner!
	provisionerRename(id: UUID!, name: String!): Provisioner!
	provisionerDeactivate(id: UUID!): Provisioner!
	provisionerRegenerateToken(id: UUID!): Provisioner!
	"""
	Creates a new log for given `project_id` and returns the log.
	"""
	logCreate(level: String!, message: String!): Log!
	"""
	Updates the subscription for the current user.
	"""
	subscriptionUpdate(tier: Tier!, paymentMethod: String): String
	"""
	Updates the subscription for the current user.
	"""
	paymentMethodCreate(number: String!, expMonth: Int!, expYear: Int!, cvc: String!): PaymentMethod!
	"""
	Creates a new family for a user and returns the family upon successful creation.
	"""
	familyCreate(definition: String!): Family!
	"""
	Creates a new attachment record and returns the ID of the created record.
	"""
	attachmentCreate(data: Upload!): Attachment!
	"""
	Creates a new block_schema and returns the block_schema.
	"""
	blockSchemaCreate(projectId: UUID!, name: String!, schema: String!, generator: String, toBytes: String, fromBytes: String, memoryAddress: Int, length: Int, source: BlockSource!, isDeviceIdentifier: Boolean!): BlockSchema!
	"""
	Re-name a block schema
	"""
	blockSchemaRename(id: UUID!, name: String!): UUID!
	blockSchemaSetIdentifier(id: UUID!, identifier: Boolean!): UUID!
	blockSchemaDeactivate(id: UUID!): BlockSchema!
	"""
	Creates a new block for given `project_id` and returns the block.
	"""
	blockCreate(schemaName: String!, data: JSON!): Block!
	blockCreateFromBytes(schemaName: String!, data: [Int!]!): Block!
	"""
	Creates a new run for the currently in-session device and returns the run.
	"""
	runCreate: Run!
	"""
	Finish provisioning for a run.
	"""
	runFinish: UUID!
	"""
	Start a provisioning step on the currently-active run.
	"""
	startStep(description: String!): UUID!
	"""
	Start a provisioning step on the currently-active run.
	"""
	finishStep(passed: Boolean!): UUID!
	"""
	Create a new requirement for given `project_id`.
	"""
	requirementCreate(projectId: UUID!, schemaId: UUID!, name: String!, description: String, lowerLimit: Float, inclusiveLower: Boolean!, upperLimit: Float, inclusiveUpper: Boolean!): Requirement!
	"""
	Deactivate a requirement such that it is no longer checked.
	"""
	requirementDeactivate(id: UUID!): UUID!
}

"""
ISO 8601 combined date and time without timezone.

# Examples

* `2015-07-01T08:59:60.123`,
"""
scalar NaiveDateTime

type OauthData {
	authUrl: String!
	csrfToken: String!
	nonce: String
}

type OauthUser {
	subject: String!
	provider: String!
}

union Owner = User | Group

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

type PaymentMethod {
	id: String!
}

type Project {
	id: UUID!
	name: String!
	chip: Chip!
	binary(id: UUID!): Binary!
	"""
	Returns the newest binary for given project id according to semver.
	"""
	binaryNewest: Binary
	binaries: [Binary!]!
	device(id: UUID!): Device!
	devices(after: String, first: Int, filter: String): DeviceConnection!
	owner: Owner!
	provisioner(id: UUID!): Provisioner!
	provisioners: [Provisioner!]!
	blockSchemas: [BlockSchema!]!
	blockSchema(id: UUID!): BlockSchema!
	requirements: [Requirement!]!
	requirement(id: UUID!): Requirement!
}

type Provisioner {
	id: UUID!
	projectId: UUID!
	currentDeviceId: UUID
	name: String!
	token: String
	active: Boolean!
	creationDate: NaiveDateTime!
	changeDate: NaiveDateTime!
	project: Project!
	currentDevice: Device
	currentRun: Run
}

type ProvisionerReleases {
	ui: [Release!]!
}

type QueryRoot {
	"""
	Returns the data that is required for the frontend to work.
	"""
	config: AppConfig!
	currentUser: User!
	usersPendingApproval: [User!]!
	"""
	Returns a project with a certain `id`.
	"""
	project(id: UUID!): Project!
	"""
	Returns all available targets.
	"""
	availableTargets(targetFiles: [String!]): [Target!]!
	currentProvisioner: Provisioner!
	ping: Boolean!
	"""
	Returns a subscription with a certain `id`.
	"""
	subscription(id: String!): Subscription!
	"""
	Returns the data that is required for stripe to work in the frontend.
	"""
	stripeData: StripeData!
	"""
	Returns a subscription with a certain `id`.
	"""
	paymentMethod(id: String!): PaymentMethod!
	paymentMethods: [PaymentMethod!]!
	oauthUrl(provider: String!): OauthData!
	"""
	Returns a family with a certain `id`.
	"""
	family(id: UUID!): Family!
	"""
	Returns the data that is required for the frontend to work.
	"""
	provisionerReleases: ProvisionerReleases!
}

type Release {
	version: String!
	name: String
	releaseNotes: String!
	artifacts: [Artifact!]!
}

type Requirement {
	"""
	The ID of the requirement.
	"""
	id: UUID!
	"""
	The name of the requirement.
	"""
	name: String!
	"""
	The description of the requirement.
	"""
	description: String
	"""
	The date that the requirement was created.
	"""
	creationDate: NaiveDateTime!
	"""
	The date when the requirement was deactivated.
	"""
	deactivationDate: NaiveDateTime
	"""
	Whether or not the requirement is active.
	"""
	active: Boolean!
	"""
	The ID of the [`BlockSchema`] used as the source of the requirement data.
	"""
	schemaId: UUID!
	"""
	The lower bounds limit of the requirement.
	"""
	lowerLimit: Float
	"""
	The upper bounds limit of the requirement.
	"""
	upperLimit: Float
	"""
	Indicates if the lower bound is inclusive or exclusive.
	"""
	inclusiveLower: Boolean!
	"""
	Indicates if the upper bound is inclusive or exclusive.
	"""
	inclusiveUpper: Boolean!
	"""
	The [`BlockSchema`] associated with the requirement's input data.
	"""
	schema: BlockSchema!
}

type RequirementCheck {
	id: UUID!
	requirementId: UUID!
	blockId: UUID
	passed: Boolean!
	checkDate: NaiveDateTime!
	runId: UUID!
	requirement: Requirement!
	block: Block
}

type Run {
	id: UUID!
	deviceId: UUID!
	currentStep: String!
	projectId: UUID!
	currentStepStatus: StepStatus!
	creationDate: NaiveDateTime!
	changeDate: NaiveDateTime!
	finished: Boolean!
	device: Device!
	logs: [Log!]!
	attachments: [Attachment!]!
	blocks: [Block!]!
	block(id: UUID!): Block!
	blockSchemas: [BlockSchema!]!
	requirementChecks: [RequirementCheck!]!
	requirements: [Requirement!]!
	"""
	Get the overall status of the run.
	"""
	runStatus: StepStatus!
}

enum StepStatus {
	PENDING
	PASS
	FAIL
}


type StripeData {
	publicKey: String!
}

type Subscription {
	id: String!
	user: User!
}

type SubscriptionRoot {
	"""
	Yields a new device whenever a new device is created.
	"""
	createDeviceEvent(token: String!, projectId: UUID!): Device!
	"""
	Yields a new device whenever a new device is created.
	"""
	logEvent(token: String!, runId: UUID!): Log!
	"""
	Yields a new block_schema whenever a new block_schema is created.
	"""
	createBlockSchemaEvent(token: String!, projectId: UUID!): BlockSchema!
	"""
	Yields a new device whenever a new device is created.
	"""
	createBlockEvent(token: String!, runId: UUID!): Block!
	"""
	Yields a new device whenever a new device is created.
	"""
	createRunEvent(token: String!, deviceId: UUID!): Run!
}

type Target {
	name: String!
}

enum Tier {
	FREE
	BASE
	FULL
}

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID

scalar Upload

type User {
	id: UUID!
	stripeCustomerId: String
	username: String!
	email: String!
	tier: Tier!
	admin: Boolean!
	userType: UserType!
	oauthUser: OauthUser
	creationDate: NaiveDateTime!
	changeDate: NaiveDateTime!
	projects: [Project!]!
	families: [Family!]!
	groups: [Group!]!
	subscription: Subscription
}

enum UserType {
	NATIVE
	OAUTH
}

schema {
	query: QueryRoot
	mutation: MutationRoot
	subscription: SubscriptionRoot
}
