# This file was automatically generated by the backend
# Manual edits will not be persisted.

type AppConfig {
	name: String!
	apiUrl: String!
	frontendUrl: String!
}

type Artifact {
	name: String!
	url: String!
	signature: String
}

type Attachment {
	id: UUID!
	runId: UUID!
	name: String!
	mimeType: String!
	data: [Int!]!
	run: Run!
}

type Binary {
	id: UUID!
	creationDate: DateTime!
	deletionDate: DateTime
	chipId: UUID!
	chip: Chip!
	version: String!
	versionMajor: Int!
	versionMinor: Int!
	versionPatch: Int!
	analysis: BinaryAnalysis
	active: Boolean!
	parts: [BinaryPart!]!
}

type BinaryAnalysis {
	nvmSize: Int!
}

enum BinaryKind {
	ELF
	HEX
	BIN
}

type BinaryPart {
	id: UUID!
	name: String
	binaryId: UUID!
	kind: BinaryKind!
	memoryOffset: Int
	imageHash: [Int!]!
	analysis: BinaryPartAnalysis
	creationDate: NaiveDateTime!
	changeDate: NaiveDateTime!
}

type BinaryPartAnalysis {
	rtt: RttAnalysis!
	nvmSize: Int!
}

type Block {
	"""
	The globally unique ID of this block.
	"""
	id: UUID!
	"""
	The device this block belongs to.
	"""
	run: Run!
	"""
	The schema of the block.
	
	The schema is a contract that has to be fulfilled for the block to be created.
	"""
	schema: BlockSchema!
	"""
	The data this block stores, in JSON format.
	"""
	dataDecoded: JSON!
	"""
	The data this block stores, in a continuous byte slice.
	
	This automatically transfers the stored data into a slice of bytes which can be written
	to device memory.
	"""
	byteSlice(chipId: UUID!): [Int!]!
}

type BlockSchema {
	id: UUID!
	isDeviceIdentifier: Boolean!
	projectId: UUID!
	name: String!
	displayName: String!
	schema: String!
	generator: String
	memorySource: MemoryEndpoint
	memorySink(chipId: UUID!): MemoryEndpoint!
	memorySinks: [MemoryEndpoint!]!
	creationDate: DateTime!
	active: Boolean!
	deletionDate: DateTime
	"""
	Determine if this schema can be used for requirements.
	"""
	supportsRequirements: Boolean!
	requirements: [Requirement!]!
}


type Chip {
	id: UUID!
	projectId: UUID!
	name: String!
	partNumber: String!
	nvmSize: Int
	active: Boolean!
	creationDate: DateTime!
	changeDate: DateTime!
	deletionDate: DateTime
	"""
	Returns true if the chip part number is natively supported by probe-rs.
	"""
	isSupported: Boolean!
	"""
	Returns the newest binary for given project id according to semver.
	"""
	binaryNewest: Binary
	binaries: [Binary!]!
	binary(id: UUID!): Binary!
}

input ChipEndpoint {
	chipId: UUID!
	address: Int!
	length: Int!
	transform: String!
}

type DataBlock {
	blockSchema: BlockSchema!
}

"""
Implement the DateTime<Utc> scalar

The input/output is a string in RFC3339 format.
"""
scalar DateTime

type Device {
	id: UUID!
	name: String
	projectId: UUID!
	creationDate: DateTime!
	changeDate: DateTime!
	project: Project!
	runs: [Run!]!
	"""
	The run with given UUID.
	
	If no UUID is given, the most recent run is returned.
	"""
	run(id: UUID): Run!
	"""
	Whether or not the device is active.
	"""
	active: Boolean!
	"""
	The date when the device was deactivated.
	"""
	deletionDate: DateTime
}

type DeviceConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [DeviceEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Device!]!
	numDevices: Int!
}

"""
An edge in a connection.
"""
type DeviceEdge {
	"""
	The item at the end of the edge
	"""
	node: Device!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

type Family {
	id: UUID!
	definition: String!
	owner: Owner!
}

input FinishStepData {
	binaryId: UUID
}

type FlashChip {
	chipId: UUID!
	command: String
	chip: Chip!
}


type Group {
	id: UUID!
	name: String!
	users: [User!]!
	creationDate: DateTime!
	changeDate: DateTime!
	projects: [Project!]!
}


input InputDataBlock {
	blockSchemaId: UUID
}

input InputFlashChip {
	chipId: UUID
	command: String
}

input InputIntegrationsSettings {
	telegram: InputTelegramSettings!
	matrix: InputMatrixSettings!
}

input InputMatrixSettings {
	rooms: [String!]!
}

input InputPlaybook {
	version: Int
	stations: [InputStation!]!
}

input InputProjectSettings {
	integrations: InputIntegrationsSettings!
}

input InputRunCommand {
	command: String
	directory: String
}

input InputStation {
	name: String
	color: String
	steps: [InputStep!]!
}

input InputStep {
	id: UUID!
	label: String
	kind: InputStepKind!
}

input InputStepKind {
	dataBlock: InputDataBlock
	flashChip: InputFlashChip
	runCommand: InputRunCommand
}

input InputTelegramSettings {
	chatIds: [Int!]!
}

input InsertBinaryPart {
	name: String
	kind: BinaryKind!
	memoryOffset: Int
	image: Upload!
}


type IntegrationsSettings {
	telegram: TelegramSettings!
	matrix: MatrixSettings!
}

"""
A scalar that can represent any JSON value.
"""
scalar JSON

type Log {
	id: UUID!
	runId: UUID!
	level: String!
	message: String!
	creationDate: DateTime!
	run: Run!
}

type MatrixSettings {
	rooms: [String!]!
}

scalar MemoryAddress

type MemoryEndpoint {
	id: UUID!
	schema: BlockSchema!
	chip: Chip!
	sink: Boolean!
	address: MemoryAddress!
	length: Int!
	creationDate: DateTime!
	active: Boolean!
	deletionDate: DateTime
}

type MutationRoot {
	"""
	Creates a new device for given `project_id` and returns the device.
	"""
	deviceCreate: Device!
	"""
	Delete a device, making it no longer appear as being linked to the project.
	"""
	deviceDelete(id: UUID!): UUID!
	signIn(email: String!, password: String!): String!
	"""
	Sign in with a given OAuth provider.
	
	# Arguments
	* `provider`: The provider to be used e.g. `google` or `github`.
	* `code`: The code that was returned from the request we sent to the provider.
	For more info see documentation on OAuth CSRF attack mitigation.
	* `nonce`: The nonce that was sent to the OIDC provider to mitigate replay attacks.
	This nonce is only required for real OIDC providers and not all OAuth providers.
	"""
	signInWithOauth(provider: String!, code: String!, csrfToken: String, nonce: String): String!
	refresh(token: String!, impersonate: UUID): String!
	userCreate(email: String!, password: String!): User!
	userConfirm(token: String!): Boolean!
	userApprove(id: UUID!): UUID!
	userResendConfirmCode(email: String!): Boolean!
	userRequestPasswordReset(email: String!): Boolean!
	userResetPassword(token: String!, newPassword: String!): Boolean!
	"""
	Change the current user's password.
	"""
	changePassword(currentPassword: String!, newPassword: String!): Boolean!
	"""
	Creates a new binary with the specified chip
	"""
	binaryCreate(chipId: UUID!, version: String!, parts: [InsertBinaryPart!]!): Binary!
	"""
	Delete a binary, making it no longer appear as being linked to the project.
	"""
	binaryDelete(id: UUID!): UUID!
	"""
	Creates a new project for a user and returns the project upon successful creation.
	"""
	projectCreate(name: String!, groupOwner: UUID): Project!
	"""
	Delete a project, making it no longer appear as being linked to the user.
	"""
	projectDelete(id: UUID!): UUID!
	"""
	Change the owner of a project to a new user or group
	"""
	projectTransfer(id: UUID!, ownerId: UUID!): UUID!
	"""
	Update settings on a project.
	"""
	projectSettingsUpdate(id: UUID!, settings: InputProjectSettings!): UUID!
	provisionerCreate(name: String!, station: String!, projectId: UUID!): Provisioner!
	provisionerRename(id: UUID!, name: String!): Provisioner!
	provisionerAssignStation(id: UUID!, station: String!): Provisioner!
	"""
	Delete a provisioner, making it no longer appear as being linked to the project.
	"""
	provisionerDelete(id: UUID!): UUID!
	provisionerRegenerateToken(id: UUID!): Provisioner!
	"""
	Creates a new log for given `project_id` and returns the log.
	"""
	logCreate(level: String!, message: String!): Log!
	"""
	Updates the subscription for the current user.
	"""
	subscriptionUpdate(tier: Tier!, paymentMethod: String): String
	"""
	Updates the subscription for the current user.
	"""
	paymentMethodCreate(number: String!, expMonth: Int!, expYear: Int!, cvc: String!): PaymentMethod!
	"""
	Creates a new family for a user and returns the family upon successful creation.
	"""
	familyCreate(definition: String!): Family!
	"""
	Creates a new attachment record and returns the ID of the created record.
	"""
	attachmentCreate(data: Upload!): Attachment!
	"""
	Creates a new block_schema and returns the block_schema.
	"""
	blockSchemaCreate(projectId: UUID!, name: String!, schema: String!, generator: String, memorySource: ChipEndpoint, memorySinks: [ChipEndpoint!]!, isDeviceIdentifier: Boolean!): BlockSchema!
	"""
	Re-name a block schema
	"""
	blockSchemaRename(id: UUID!, name: String!): UUID!
	blockSchemaSetIdentifier(id: UUID!, identifier: Boolean!): UUID!
	"""
	Delete a block schema, making it no longer appear as being linked to the project.
	"""
	blockSchemaDelete(id: UUID!): UUID!
	"""
	Creates a new block for given `project_id` and returns the block.
	"""
	blockCreate(schemaName: String!, data: JSON!): Block!
	blockCreateFromBytes(schemaName: String!, data: [Int!]!): Block!
	"""
	Creates a new run for the currently in-session device and returns the run.
	"""
	runCreate(station: String!): Run!
	"""
	Creates a new run for an existing device and returns the run.
	"""
	runCreateFor(identifier: String!, station: String!): Run!
	"""
	Finish provisioning for a run.
	"""
	runFinish: UUID!
	"""
	Start a provisioning step on the currently-active run.
	"""
	startStep(description: String!): UUID!
	"""
	Start a provisioning step on the currently-active run.
	"""
	finishStep(passed: Boolean!, data: FinishStepData): UUID!
	"""
	Create a new requirement for given `project_id`.
	"""
	requirementCreate(projectId: UUID!, schemaId: UUID!, name: String!, description: String, lowerLimit: Float, inclusiveLower: Boolean!, upperLimit: Float, inclusiveUpper: Boolean!): Requirement!
	"""
	Delete a requirement,making it no longer linked to the project.
	"""
	requirementDelete(id: UUID!): UUID!
	"""
	Updates the draft playbook with the given new playbook.
	"""
	playbookUpdate(projectId: UUID!, playbook: InputPlaybook!): Boolean!
	playbookSave(projectId: UUID!): Int!
	"""
	Creates a new project for a user and returns the project upon successful creation.
	"""
	chipCreate(projectId: UUID!, name: String!, partNumber: String!): Chip!
	"""
	Delete a chip, making it no longer appear as being linked to the project.
	"""
	chipDelete(id: UUID!): UUID!
	groupCreate(name: String!): Group!
	groupAddUser(groupId: UUID!, userEmail: String!): UUID!
	groupRemoveUser(groupId: UUID!, userId: UUID!): UUID!
}

"""
ISO 8601 combined date and time without timezone.

# Examples

* `2015-07-01T08:59:60.123`,
"""
scalar NaiveDateTime

type Notification {
	id: UUID!
	projectId: UUID
	event: JSON!
	retry: Int!
	creationDate: DateTime!
	deliveryDate: DateTime
	project: Project
}

type NotificationConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [NotificationEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [Notification!]!
	numNotifications: Int!
}

"""
An edge in a connection.
"""
type NotificationEdge {
	"""
	The item at the end of the edge
	"""
	node: Notification!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

type OauthData {
	authUrl: String!
	csrfToken: String!
	nonce: String
}

type OauthUser {
	subject: String!
	provider: String!
}

union Owner = User | Group

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

type PaymentMethod {
	id: String!
}

type Playbook {
	projectId: UUID!
	version: Int
	stations: [Station!]!
	station(name: String!): Station
	project: Project!
}

type Project {
	id: UUID!
	name: String!
	active: Boolean!
	settings: ProjectSettings!
	creationDate: DateTime!
	changeDate: DateTime!
	deletionDate: DateTime
	chip(id: UUID!): Chip!
	"""
	Get the currently-active playbook for the project.
	"""
	playbook: Playbook!
	"""
	Get all playbooks registered with the project.
	"""
	playbooks: [Playbook!]!
	chips: [Chip!]!
	device(id: UUID!): Device!
	devices(after: String, first: Int, filter: String): DeviceConnection!
	owner: Owner!
	provisioner(id: UUID!): Provisioner!
	provisioners: [Provisioner!]!
	blockSchemas: [BlockSchema!]!
	blockSchema(id: UUID!): BlockSchema!
	requirements: [Requirement!]!
	requirement(id: UUID!): Requirement!
	notifications(after: String, first: Int, filter: String): NotificationConnection!
}

type ProjectSettings {
	integrations: IntegrationsSettings!
}

type Provisioner {
	id: UUID!
	projectId: UUID!
	currentDeviceId: UUID
	name: String!
	token: String
	active: Boolean!
	creationDate: DateTime!
	changeDate: DateTime!
	project: Project!
	currentDevice: Device
	currentRun: Run
	station: String!
	steps: [Step!]!
}

type ProvisionerReleases {
	ui: [Release!]!
}

type QueryRoot {
	"""
	Returns the data that is required for the frontend to work.
	"""
	config: AppConfig!
	currentUser: User!
	usersPendingApproval: [User!]!
	users: [User!]!
	"""
	Lists all projects.
	"""
	projects: [Project!]!
	"""
	Returns a project with a certain `id`.
	"""
	project(id: UUID!): Project!
	"""
	Returns all available targets.
	"""
	availableTargets(targetFiles: [String!]): [Target!]!
	currentProvisioner: Provisioner!
	ping: Boolean!
	"""
	Returns a subscription with a certain `id`.
	"""
	subscription(id: String!): Subscription!
	"""
	Returns the data that is required for stripe to work in the frontend.
	"""
	stripeData: StripeData!
	"""
	Returns a subscription with a certain `id`.
	"""
	paymentMethod(id: String!): PaymentMethod!
	paymentMethods: [PaymentMethod!]!
	oauthUrl(provider: String!): OauthData!
	"""
	Returns a family with a certain `id`.
	"""
	family(id: UUID!): Family!
	"""
	Returns the data that is required for the frontend to work.
	"""
	provisionerReleases: ProvisionerReleases!
	group(id: UUID!): Group!
}

type Release {
	version: String!
	name: String
	releaseNotes: String!
	artifacts: [Artifact!]!
}

type Requirement {
	"""
	The ID of the requirement.
	"""
	id: UUID!
	"""
	The name of the requirement.
	"""
	name: String!
	"""
	The description of the requirement.
	"""
	description: String
	"""
	The date that the requirement was created.
	"""
	creationDate: DateTime!
	"""
	The date when the requirement was deactivated.
	"""
	deletionDate: DateTime
	"""
	Whether or not the requirement is active.
	"""
	active: Boolean!
	"""
	The ID of the [`BlockSchema`] used as the source of the requirement data.
	"""
	schemaId: UUID!
	"""
	The lower bounds limit of the requirement.
	"""
	lowerLimit: Float
	"""
	The upper bounds limit of the requirement.
	"""
	upperLimit: Float
	"""
	Indicates if the lower bound is inclusive or exclusive.
	"""
	inclusiveLower: Boolean!
	"""
	Indicates if the upper bound is inclusive or exclusive.
	"""
	inclusiveUpper: Boolean!
	"""
	The [`BlockSchema`] associated with the requirement's input data.
	"""
	schema: BlockSchema!
}

type RequirementCheck {
	id: UUID!
	requirementId: UUID!
	blockId: UUID
	passed: Boolean!
	checkDate: DateTime!
	runId: UUID!
	requirement: Requirement!
	block: Block
}

type RttAnalysis {
	headerLocation: Int
}

type Run {
	id: UUID!
	deviceId: UUID!
	projectId: UUID!
	provisioner: Provisioner
	station: String!
	creationDate: DateTime!
	changeDate: DateTime!
	finished: Boolean!
	device: Device!
	logs: [Log!]!
	attachments: [Attachment!]!
	blocks: [Block!]!
	block(id: UUID!): Block!
	blockForSchema(schemaId: UUID!): Block
	blockSchemas: [BlockSchema!]!
	requirementChecks: [RequirementCheck!]!
	requirements: [Requirement!]!
	"""
	Get the overall status of the run.
	"""
	runStatus: StepStatus!
	steps: [RunStep!]!
	"""
	Reports any reasons for a run failure.
	"""
	errors: [String!]!
}

type RunCommand {
	command: String
	directory: String
}

type RunStep {
	id: UUID!
	runId: UUID!
	stepId: UUID!
	status: StepStatus!
	station: String!
	creationDate: DateTime!
	changeDate: DateTime!
	data: RunStepData!
	step: Step!
}

type RunStepData {
	binaryId: UUID
	binary: Binary
}

type Station {
	name: String!
	color: String!
	steps: [Step!]!
}

type Step {
	id: UUID!
	kind: StepKind!
	position: Int!
	station: String!
	label: String
	creationDate: NaiveDateTime!
	changeDate: NaiveDateTime!
}

union StepKind = DataBlock | FlashChip | RunCommand

enum StepStatus {
	PENDING
	PASS
	FAIL
}


type StripeData {
	publicKey: String!
}

type Subscription {
	id: String!
	user: User!
}

type SubscriptionRoot {
	"""
	Yields a new device whenever a new device is created.
	"""
	createDeviceEvent(token: String!, projectId: UUID!): Device!
	"""
	Yields a new requirement whenever one is created.
	"""
	createRequirementEvent(token: String!, projectId: UUID!): Requirement!
	"""
	Yields a new device whenever a new device is created.
	"""
	logEvent(token: String!, runId: UUID!): Log!
	"""
	Yields a new block_schema whenever a new block_schema is created.
	"""
	createBlockSchemaEvent(token: String!, projectId: UUID!): BlockSchema!
	"""
	Yields a new device whenever a new device is created.
	"""
	createBlockEvent(token: String!, runId: UUID!): Block!
	"""
	Yields a new device whenever a new device is created.
	"""
	createRunEvent(token: String!, deviceId: UUID!): Run!
}

type Target {
	name: String!
}

type TelegramSettings {
	chatIds: [Int!]!
}

enum Tier {
	"""
	Only a very limited free featureset.
	"""
	FREE
	"""
	The basic service with all it's basic features.
	"""
	BASE
	"""
	The full featureset unlocked.
	"""
	FULL
}

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID

scalar Upload

type User {
	id: UUID!
	stripeCustomerId: String
	email: String!
	tier: Tier!
	admin: Boolean!
	userType: UserType!
	oauthUser: OauthUser
	creationDate: DateTime!
	changeDate: DateTime!
	projects: [Project!]!
	families: [Family!]!
	groups: [Group!]!
	subscription: Subscription
}

enum UserType {
	NATIVE
	OAUTH
}

directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
schema {
	query: QueryRoot
	mutation: MutationRoot
	subscription: SubscriptionRoot
}
